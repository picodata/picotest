mod utils;

use darling::ast::NestedMeta;
use darling::{Error, FromMeta};
use proc_macro::TokenStream;
use quote::quote;
use syn::parse::{Parse, ParseStream};
use syn::{parse_macro_input, parse_quote, Error as SynError, Ident, Item, ItemFn};

fn plugin_timeout_secs_default() -> u64 {
    5
}

fn parse_attrs<T: FromMeta>(attr: TokenStream) -> Result<T, TokenStream> {
    NestedMeta::parse_meta_list(attr.into())
        .map_err(Error::from)
        .and_then(|attr| T::from_list(&attr))
        .map_err(|e| TokenStream::from(e.write_errors()))
}

macro_rules! parse_attrs {
    ($attr:ident as $ty:ty) => {
        match parse_attrs::<$ty>($attr) {
            Ok(obj) => obj,
            Err(err) => return err,
        }
    };
}

#[derive(Debug, FromMeta)]
struct PluginCfg {
    path: Option<String>,
    #[darling(default = "plugin_timeout_secs_default")]
    timeout: u64,
}

#[derive(Debug, FromMeta)]
struct UnitTestAttributes {
}

struct UnitTestFunction {
    func: ItemFn,
}

impl Parse for UnitTestFunction {
    fn parse(input: ParseStream) -> Result<Self, SynError> {
        let func = input.parse::<ItemFn>().map_err(|err| {
            SynError::new(
                err.span(),
                "The #[picotest_unit] macro is only valid when called on a function.",
            )
        })?;
        Ok(UnitTestFunction { func })
    }
}

#[proc_macro_attribute]
pub fn picotest(attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as Item);
    let cfg = parse_attrs!(attr as PluginCfg);

    let path = cfg.path;
    let timeout_secs = cfg.timeout;
    let input = match input {
        Item::Fn(func) => Item::Fn(utils::process_test_function(func, &path, timeout_secs)),
        Item::Mod(mut m) => {
            let (brace, items) = m.content.unwrap();
            let mut items: Vec<Item> = items
                .into_iter()
                .map(|item| {
                    if let Item::Fn(func) = item {
                        Item::Fn(utils::process_test_function(func, &path, timeout_secs))
                    } else {
                        item
                    }
                })
                .collect();

            let mut content = vec![parse_quote!(
                use picotest::*;
            )];
            content.push(parse_quote!(
                use std::panic;
            ));
            content.append(&mut items);

            m.content = Some((brace, content));
            Item::Mod(m)
        }
        _ => {
            panic!("The #[picotest] macro is only valid when called on a function or module.");
        }
    };
    TokenStream::from(quote! (#input))
}

static UNIT_COUNTER: std::sync::atomic::AtomicUsize = std::sync::atomic::AtomicUsize::new(1);

#[proc_macro_attribute]
pub fn picotest_unit(attrs: TokenStream, tokens: TokenStream) -> TokenStream {
    let _attrs = parse_attrs!(attrs as UnitTestAttributes);
    let test_fn = parse_macro_input!(tokens as UnitTestFunction).func;

    let test_fn_attrs = test_fn.attrs.clone();
    let test_fn_ident = test_fn.sig.ident.clone();
    let test_fn_block = test_fn.block;
    let test_fn_name = test_fn.sig.ident.to_string();

    // Name of the function to be invoked on instance-side to obtain test information
    let test_idx = UNIT_COUNTER.fetch_add(1, std::sync::atomic::Ordering::Acquire);
    let test_locator_name = format!("test_impl_{test_idx}_{test_fn_name}");
    let test_locator_ident = Ident::new(&test_locator_name, test_fn_ident.span());

    // Render 2 functions:
    // 1. Exported test function locator, which can be accessed via lua on demand to
    //    run non-exported function with test payload. Locator name uses autogenerated
    //    name, as procedural macro can not resolve current path with std::module_path!()
    //    due to macro expansion ordering.
    // 2. Test function with same name this macro was provided. Depending on build
    //    profile (test or non-test) this function does contain either client side
    //    of test (which starts picodata cluster, setups plugin and enters instance via lua),
    //    or server side of test (with payload we have been told to wrap)
    quote! {
        #[allow(dead_code)]
        #[unsafe(no_mangle)]
        pub extern "C" fn #test_locator_ident() -> fn() {
            #test_fn_ident
        }

        #[cfg_attr(test,test)]
        #[cfg_attr(not(test),inline(never))]
        #( #test_fn_attrs )*
        fn #test_fn_ident() {
            #[cfg(not(test))]
            {
                #test_fn_block
            }
            #[cfg(test)] 
            {
                const TEST_FULL_NAME: &'static str = concat!(std::module_path!(), "::", #test_fn_name);
                let (pkg_name, test_name) = TEST_FULL_NAME.split_once("::").unwrap();
                picotest::internal::execute_test(pkg_name, #test_locator_name, test_name);
            }
        }
    }
    .into()
}
